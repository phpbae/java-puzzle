# java-puzzle
자바 퍼즐러 코드 작성


#### 1. 홀수확인

- 나머지 연산을 사용할 때는 항상 피연산자의 부호와 결과가 어떻게 나올지 생각을 해야함.
```
확인하고자 하는 숫자를 2로 나눈 나머지가 1이면 홀수.

하지만, 나머지 연산의 결과는 항상 왼쪽 피연산자 부호와 같다.
- 3%2 = 1
- 3%-2 = -1
- -3%2 = -1

i % 2 == 1  -> 음수 홀수값이 들어오는 경우 항상 false를 리턴.

i % 2 != 0 -> 음수 홀수값이 들어와도 정상적인 결과를 리턴.

만약, 성능까지 고려한다면 비트연산자를 이용.
입력 숫자 n에서 홀수, 짝수를 결정 하는 것은 마지막 자리 숫자
ex 1)
10 이라는 10진수 정수를 예로 들면
10은 2진수로 표현하면 1010 이고,
1은 2진수로 그냥 1이다.
10 & 1 은 1010 & 1과 동일함.

1010
   1
그럼 1010의 마지막 자리는 0 이고, 0과 1을 &(논리곱) 연산 하면 0 이기 때문에
짝수가 된다. 1과 논리곱 연산을 했으니 false가 나온다.

비트 논리곱(&)은 비트 단위로 논리곱 연산을 합니다. 
예를 들어 6&5를 하면 
6은 이진수로 110, 
5는 이진수로 101, 
이므로 6&5의 연산 결과는 이진수 100로 10진수 4입니다.

110
101
100 -> 2^2 = 4
```

#### 2. 변화를 위한 시간

- 자바는 float / double 자료형으로 정확한 연산을 수행할 수 없음.
- 자바는 이진 부동소수점 연산을 사용. -> 빠르지만, 미세한 오차가 있음
- 오차가 없는 십진 부동소수점 연산도 존재하지만, 자바 기본 자료형 연산에서 이를 지원X
- 정확한 결과가 필요하다면, float / double 자료형을 사용하지 말고 int, long, BigDecimal 자료형을 사용. 
```

double a = 2.00;
double b = 1.10;
System.out.println(a - b); // 0.90 ?
결과 : 0.8999999999999999 
이진 부동소수점 연산을 사용하기 떄문에, 미세한 오차가 발생.  따라서, 금융 계산에서 사용하면 큰일.


//주의 : 생성자에 매개변수로 입력한 값을 그대로 표현
BigDecimal decimalDouble = new BigDecimal(b); // 1.10 = 1.100000000000000088817841970012523233890533447265625
BigDecimal decimalString = new BigDecimal("2.00"); // String 생성자를 이용하자.

decimalDouble : 1.100000000000000088817841970012523233890533447265625
decimalString : 2.00

System.out.println("2.00 - 1.10 = " + new BigDecimal("2.00").subtract(new BigDecimal("1.10")));

결과 : 2.00 - 1.10 = 0.90
```